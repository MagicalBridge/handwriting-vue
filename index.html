<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="app" style="font-size:16px;">{{name}}world</div>
  <script src="./dist/umd/vue.js"></script>
  <script>
    // 混合
    // Vue.mixin({
    //   created: function a() {
    //     console.log("我是全局的 mixin a")
    //   }
    // })

    // Vue.mixin({
    //   created: function b() {
    //     console.log("我是全局的 mixin b")
    //   }
    // })

    let vm = new Vue({
      el: '#app',
      data() {
        return {
          name: 'louis'
        }
      },
      // created() { // 可以认为生命周期函数是回调函数先订阅 在需要执行的地方执行
      //   console.log("我是实例vue上面的created方法");
      // }
      // render(h) { // 先找render
      //   h('<div>', { id: 'a', }, 'hello')
      // }
      // template
    });
    console.log(vm);
    // 渲染的操作:
    // 1、默认会先找render方法 这个render方法里面有一个 h方法, 类似于 react中的createElement 
    // 这个渲染方法的优先级要高,
    // 2、如果没有找到render方法 会去找 template 
    // 3、如果template也没有传 就看看你有没有el属性 找el 中的指定的内容来进行渲染页面
    // 最终会将template变成 render 方法，总结一句话就是，vue 渲染的时候最终只认 render 函数

    // 设置一个场景，就是每次渲染完之后过来一秒钟修改数据，看看是什么效果
    // setTimeout(() => {
    //   vm.name = '褚鹏飞'
    // }, 1000)
  </script>
</body>

</html>